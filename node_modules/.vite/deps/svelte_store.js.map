{
  "version": 3,
  "sources": ["../../svelte/src/reactivity/utils.js", "../../svelte/src/reactivity/create-subscriber.js", "../../svelte/src/store/index-client.js"],
  "sourcesContent": ["/** @import { Source } from '#client' */\r\nimport { set } from '../internal/client/reactivity/sources.js';\r\n\r\n/** @param {Source<number>} source */\r\nexport function increment(source) {\r\n\tset(source, source.v + 1);\r\n}\r\n", "import { get, tick, untrack } from '../internal/client/runtime.js';\r\nimport { effect_tracking, render_effect } from '../internal/client/reactivity/effects.js';\r\nimport { source } from '../internal/client/reactivity/sources.js';\r\nimport { increment } from './utils.js';\r\n\r\n/**\r\n * Returns a `subscribe` function that, if called in an effect (including expressions in the template),\r\n * calls its `start` callback with an `update` function. Whenever `update` is called, the effect re-runs.\r\n *\r\n * If `start` returns a function, it will be called when the effect is destroyed.\r\n *\r\n * If `subscribe` is called in multiple effects, `start` will only be called once as long as the effects\r\n * are active, and the returned teardown function will only be called when all effects are destroyed.\r\n *\r\n * It's best understood with an example. Here's an implementation of [`MediaQuery`](https://svelte.dev/docs/svelte/svelte-reactivity#MediaQuery):\r\n *\r\n * ```js\r\n * import { createSubscriber } from 'svelte/reactivity';\r\n * import { on } from 'svelte/events';\r\n *\r\n * export class MediaQuery {\r\n * \t#query;\r\n * \t#subscribe;\r\n *\r\n * \tconstructor(query) {\r\n * \t\tthis.#query = window.matchMedia(`(${query})`);\r\n *\r\n * \t\tthis.#subscribe = createSubscriber((update) => {\r\n * \t\t\t// when the `change` event occurs, re-run any effects that read `this.current`\r\n * \t\t\tconst off = on(this.#query, 'change', update);\r\n *\r\n * \t\t\t// stop listening when all the effects are destroyed\r\n * \t\t\treturn () => off();\r\n * \t\t});\r\n * \t}\r\n *\r\n * \tget current() {\r\n * \t\tthis.#subscribe();\r\n *\r\n * \t\t// Return the current state of the query, whether or not we're in an effect\r\n * \t\treturn this.#query.matches;\r\n * \t}\r\n * }\r\n * ```\r\n * @param {(update: () => void) => (() => void) | void} start\r\n * @since 5.7.0\r\n */\r\nexport function createSubscriber(start) {\r\n\tlet subscribers = 0;\r\n\tlet version = source(0);\r\n\t/** @type {(() => void) | void} */\r\n\tlet stop;\r\n\r\n\treturn () => {\r\n\t\tif (effect_tracking()) {\r\n\t\t\tget(version);\r\n\r\n\t\t\trender_effect(() => {\r\n\t\t\t\tif (subscribers === 0) {\r\n\t\t\t\t\tstop = untrack(() => start(() => increment(version)));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsubscribers += 1;\r\n\r\n\t\t\t\treturn () => {\r\n\t\t\t\t\ttick().then(() => {\r\n\t\t\t\t\t\t// Only count down after timeout, else we would reach 0 before our own render effect reruns,\r\n\t\t\t\t\t\t// but reach 1 again when the tick callback of the prior teardown runs. That would mean we\r\n\t\t\t\t\t\t// re-subcribe unnecessarily and create a memory leak because the old subscription is never cleaned up.\r\n\t\t\t\t\t\tsubscribers -= 1;\r\n\r\n\t\t\t\t\t\tif (subscribers === 0) {\r\n\t\t\t\t\t\t\tstop?.();\r\n\t\t\t\t\t\t\tstop = undefined;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t};\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n}\r\n", "/** @import { Readable, Writable } from './public.js' */\r\nimport {\r\n\teffect_root,\r\n\teffect_tracking,\r\n\trender_effect\r\n} from '../internal/client/reactivity/effects.js';\r\nimport { get, writable } from './shared/index.js';\r\nimport { createSubscriber } from '../reactivity/create-subscriber.js';\r\nimport {\r\n\tactive_effect,\r\n\tactive_reaction,\r\n\tset_active_effect,\r\n\tset_active_reaction\r\n} from '../internal/client/runtime.js';\r\n\r\nexport { derived, get, readable, readonly, writable } from './shared/index.js';\r\n\r\n/**\r\n * @template V\r\n * @overload\r\n * @param {() => V} get\r\n * @param {(v: V) => void} set\r\n * @returns {Writable<V>}\r\n */\r\n/**\r\n * @template V\r\n * @overload\r\n * @param {() => V} get\r\n * @returns {Readable<V>}\r\n */\r\n/**\r\n * Create a store from a function that returns state, and (to make a writable store), an\r\n * optional second function that sets state.\r\n *\r\n * ```ts\r\n * import { toStore } from 'svelte/store';\r\n *\r\n * let count = $state(0);\r\n *\r\n * const store = toStore(() => count, (v) => (count = v));\r\n * ```\r\n * @template V\r\n * @param {() => V} get\r\n * @param {(v: V) => void} [set]\r\n * @returns {Writable<V> | Readable<V>}\r\n */\r\nexport function toStore(get, set) {\r\n\tvar effect = active_effect;\r\n\tvar reaction = active_reaction;\r\n\tvar init_value = get();\r\n\r\n\tconst store = writable(init_value, (set) => {\r\n\t\t// If the value has changed before we call subscribe, then\r\n\t\t// we need to treat the value as already having run\r\n\t\tvar ran = init_value !== get();\r\n\r\n\t\t// TODO do we need a different implementation on the server?\r\n\t\tvar teardown;\r\n\t\t// Apply the reaction and effect at the time of toStore being called\r\n\t\tvar previous_reaction = active_reaction;\r\n\t\tvar previous_effect = active_effect;\r\n\t\tset_active_reaction(reaction);\r\n\t\tset_active_effect(effect);\r\n\r\n\t\ttry {\r\n\t\t\tteardown = effect_root(() => {\r\n\t\t\t\trender_effect(() => {\r\n\t\t\t\t\tconst value = get();\r\n\t\t\t\t\tif (ran) set(value);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t} finally {\r\n\t\t\tset_active_reaction(previous_reaction);\r\n\t\t\tset_active_effect(previous_effect);\r\n\t\t}\r\n\r\n\t\tran = true;\r\n\r\n\t\treturn teardown;\r\n\t});\r\n\r\n\tif (set) {\r\n\t\treturn {\r\n\t\t\tset,\r\n\t\t\tupdate: (fn) => set(fn(get())),\r\n\t\t\tsubscribe: store.subscribe\r\n\t\t};\r\n\t}\r\n\r\n\treturn {\r\n\t\tsubscribe: store.subscribe\r\n\t};\r\n}\r\n\r\n/**\r\n * @template V\r\n * @overload\r\n * @param {Writable<V>} store\r\n * @returns {{ current: V }}\r\n */\r\n/**\r\n * @template V\r\n * @overload\r\n * @param {Readable<V>} store\r\n * @returns {{ readonly current: V }}\r\n */\r\n/**\r\n * Convert a store to an object with a reactive `current` property. If `store`\r\n * is a readable store, `current` will be a readonly property.\r\n *\r\n * ```ts\r\n * import { fromStore, get, writable } from 'svelte/store';\r\n *\r\n * const store = writable(0);\r\n *\r\n * const count = fromStore(store);\r\n *\r\n * count.current; // 0;\r\n * store.set(1);\r\n * count.current; // 1\r\n *\r\n * count.current += 1;\r\n * get(store); // 2\r\n * ```\r\n * @template V\r\n * @param {Writable<V> | Readable<V>} store\r\n */\r\nexport function fromStore(store) {\r\n\tlet value = /** @type {V} */ (undefined);\r\n\r\n\tconst subscribe = createSubscriber((update) => {\r\n\t\tlet ran = false;\r\n\r\n\t\tconst unsubscribe = store.subscribe((v) => {\r\n\t\t\tvalue = v;\r\n\t\t\tif (ran) update();\r\n\t\t});\r\n\r\n\t\tran = true;\r\n\r\n\t\treturn unsubscribe;\r\n\t});\r\n\r\n\tfunction current() {\r\n\t\tif (effect_tracking()) {\r\n\t\t\tsubscribe();\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\treturn get(store);\r\n\t}\r\n\r\n\tif ('set' in store) {\r\n\t\treturn {\r\n\t\t\tget current() {\r\n\t\t\t\treturn current();\r\n\t\t\t},\r\n\t\t\tset current(v) {\r\n\t\t\t\tstore.set(v);\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\treturn {\r\n\t\tget current() {\r\n\t\t\treturn current();\r\n\t\t}\r\n\t};\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;AAIO,SAAS,UAAUA,SAAQ;AACjC,MAAIA,SAAQA,QAAO,IAAI,CAAC;AACzB;;;ACyCO,SAAS,iBAAiB,OAAO;AACvC,MAAI,cAAc;AAClB,MAAI,UAAU,OAAO,CAAC;AAEtB,MAAI;AAEJ,SAAO,MAAM;AACZ,QAAI,gBAAgB,GAAG;AACtB,UAAI,OAAO;AAEX,oBAAc,MAAM;AACnB,YAAI,gBAAgB,GAAG;AACtB,iBAAO,QAAQ,MAAM,MAAM,MAAM,UAAU,OAAO,CAAC,CAAC;AAAA,QACrD;AAEA,uBAAe;AAEf,eAAO,MAAM;AACZ,eAAK,EAAE,KAAK,MAAM;AAIjB,2BAAe;AAEf,gBAAI,gBAAgB,GAAG;AACtB;AACA,qBAAO;AAAA,YACR;AAAA,UACD,CAAC;AAAA,QACF;AAAA,MACD,CAAC;AAAA,IACF;AAAA,EACD;AACD;;;AClCO,SAAS,QAAQC,MAAKC,MAAK;AACjC,MAAI,SAAS;AACb,MAAI,WAAW;AACf,MAAI,aAAaD,KAAI;AAErB,QAAM,QAAQ,SAAS,YAAY,CAACC,SAAQ;AAG3C,QAAI,MAAM,eAAeD,KAAI;AAG7B,QAAI;AAEJ,QAAI,oBAAoB;AACxB,QAAI,kBAAkB;AACtB,wBAAoB,QAAQ;AAC5B,sBAAkB,MAAM;AAExB,QAAI;AACH,iBAAW,YAAY,MAAM;AAC5B,sBAAc,MAAM;AACnB,gBAAM,QAAQA,KAAI;AAClB,cAAI,IAAK,CAAAC,KAAI,KAAK;AAAA,QACnB,CAAC;AAAA,MACF,CAAC;AAAA,IACF,UAAE;AACD,0BAAoB,iBAAiB;AACrC,wBAAkB,eAAe;AAAA,IAClC;AAEA,UAAM;AAEN,WAAO;AAAA,EACR,CAAC;AAED,MAAIA,MAAK;AACR,WAAO;AAAA,MACN,KAAAA;AAAA,MACA,QAAQ,CAAC,OAAOA,KAAI,GAAGD,KAAI,CAAC,CAAC;AAAA,MAC7B,WAAW,MAAM;AAAA,IAClB;AAAA,EACD;AAEA,SAAO;AAAA,IACN,WAAW,MAAM;AAAA,EAClB;AACD;AAmCO,SAAS,UAAU,OAAO;AAChC,MAAI;AAAA;AAAA,IAA0B;AAAA;AAE9B,QAAM,YAAY,iBAAiB,CAAC,WAAW;AAC9C,QAAI,MAAM;AAEV,UAAM,cAAc,MAAM,UAAU,CAAC,MAAM;AAC1C,cAAQ;AACR,UAAI,IAAK,QAAO;AAAA,IACjB,CAAC;AAED,UAAM;AAEN,WAAO;AAAA,EACR,CAAC;AAED,WAAS,UAAU;AAClB,QAAI,gBAAgB,GAAG;AACtB,gBAAU;AACV,aAAO;AAAA,IACR;AAEA,WAAOA,KAAI,KAAK;AAAA,EACjB;AAEA,MAAI,SAAS,OAAO;AACnB,WAAO;AAAA,MACN,IAAI,UAAU;AACb,eAAO,QAAQ;AAAA,MAChB;AAAA,MACA,IAAI,QAAQ,GAAG;AACd,cAAM,IAAI,CAAC;AAAA,MACZ;AAAA,IACD;AAAA,EACD;AAEA,SAAO;AAAA,IACN,IAAI,UAAU;AACb,aAAO,QAAQ;AAAA,IAChB;AAAA,EACD;AACD;",
  "names": ["source", "get", "set"]
}
